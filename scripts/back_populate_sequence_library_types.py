"""
For easy batching of exome CNV calling it is important we know the capture type used.
VCGS kindly encodes this information in the fastq file name. This script parses all
sequences, identifies which are generated by VCGS (based on the fastq name pattern), then
updates the sequence.meta field with `facility` and `library_type` annotations.

"""
import logging
import click
import re

from sample_metadata.apis import SequenceApi
from sample_metadata.models import SequenceUpdateModel

logger = logging.getLogger(__file__)
logging.basicConfig(format='%(levelname)s (%(name)s %(lineno)s): %(message)s')
logger.setLevel(logging.INFO)

# Facility specific regular expressions
# VCGS fastq
# This is the current name format
vcgs_fastq_regex = (
    r'(?P<run_date>\d{6})_(?P<g2>[A-Z\d]+)_(?P<g3>\d{4})_'
    r'(?P<g4>[A-Z]{2}\d+)_(?P<sample_id>[\w\d-]+)_(?P<library_id>[A-Z\d-]+)_'
    r'(?P<library_type>[\w\d]+)_(?P<lane>L\d+)_(?P<read>R[12])\.fastq\.gz'
)
# Pre mid 2018 the library id was not included:
vcgs_fastq_pre2018_regex = (
    r'(?P<run_date>\d{6})_(?P<g2>[A-Z\d]+)_(?P<g3>\d{4})_'
    r'(?P<g4>[A-Z]{2}\d+)_(?P<sample_id>[\w\d-]+)_'
    r'(?P<library_type>[\w\d]+)_(?P<lane>L\d+)_(?P<read>R[12])\.fastq\.gz'
)

# Garvan fastq
garvan_fastq_regex = (
    r'(?P<flowcell_id>[A-Z0-9]+_\d)_(?P<rundate>\d{6})_'
    r'(?P<sample_id>[A-Z]{2}\d{8})_(?P<species>[\w-]+)_'
    r'(?P<library_barcode>[ACGT]+-[ACGT]+)_(?P<batch_submission_id>R_\d{6}_[A-Z]{6})_'
    r'(?P<sample_type>DNA)_(?P<lane>[A-Z]\d{3})_(?P<read>R[12])\.fastq\.gz'
)


@click.command()
@click.option(
    '--project',
    required=True,
    help='The sample-metadata project ($DATASET)',
)
@click.option(
    '-d',
    '--dummy-run',
    is_flag=True,
    default=False,
    help='Do not save changes to metamist',
)
def main(project: str, dummy_run: bool):
    """Back populate facility and library_type meta fields for existing sequences"""
    seqapi = SequenceApi()
    # Pull all the sequences
    sequences = seqapi.get_sequences_by_criteria(
        active=True,
        body_get_sequences_by_criteria={
            'projects': [project],
        },
    )

    # For logs
    updated_sequences: list[dict[str, dict]] = []

    for sequence in sequences:
        internal_sequence_id = sequence.get('id')
        current_library_type = sequence['meta'].get('library_type')

        # Quick validation
        if current_library_type:
            logging.warning(
                f'{internal_sequence_id} already has current_library_type set: {current_library_type}. Skipping'
            )
            continue

        try:
            fastq_filename = sequence.get('meta').get('reads')[0][0].get('basename')
        except (TypeError, KeyError):
            # Can't determine fastq_filename
            logging.warning(
                f'Cant extract fastq_filename for {internal_sequence_id} skipping {sequence}'
            )
            continue

        meta_fields_to_update = {}

        # Match VCGS standard fastq pattern
        if match := re.match(vcgs_fastq_regex, fastq_filename):
            meta_fields_to_update['facility'] = 'vcgs'
            meta_fields_to_update['library_type'] = match.group('library_type')

        # Match VCGS pre2018 fastq pattern
        elif match := re.match(vcgs_fastq_pre2018_regex, fastq_filename):
            meta_fields_to_update['facility'] = 'vcgs'
            meta_fields_to_update['library_type'] = match.group('library_type')

        # Match Garvan standard fastq pattern
        elif match := re.match(garvan_fastq_regex, fastq_filename):
            meta_fields_to_update['facility'] = 'garvan'

        else:
            logging.warning(
                f'No file name match found for {internal_sequence_id} skipping {fastq_filename}'
            )

        if meta_fields_to_update:
            if not dummy_run:
                seqapi.update_sequence(
                    internal_sequence_id,
                    SequenceUpdateModel(meta=meta_fields_to_update),
                )
            updated_sequences.append({internal_sequence_id: meta_fields_to_update})
        else:
            f'No sequences found to update'

    if dummy_run:
        logging.info(f'Dummy run. Would have updated {len(updated_sequences)} sequences. {updated_sequences}')
    else:
        logging.info(f'Updated {len(updated_sequences)} sequences. {updated_sequences}')


if __name__ == '__main__':
    # pylint: disable=no-value-for-parameter
    main()
