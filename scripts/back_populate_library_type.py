"""
For batching of exome CNV calling it is important we know the capture type used.
VCGS kindly encodes this information in the fastq file name. This script parses all
assays, identifies which are generated by VCGS (based on the fastq name pattern), then
updates the assay.meta field with `facility` and `library_type` annotations.
Also updates the sequencing group meta fields with the same information, if the flag is set.
"""
import asyncio
import logging
import re
from collections import defaultdict

import click

from metamist.apis import AssayApi, SequencingGroupApi
from metamist.graphql import gql, query
from metamist.models import AssayUpsert, SequencingGroupMetaUpdateModel

logger = logging.getLogger(__file__)
logging.basicConfig(
    format='%(levelname)s (%(name)s %(lineno)s): %(message)s', level=logging.INFO
)
# logger.setLevel(logging.INFO)

_sg_assays_query = gql(
    """
    query getAssaysByCriteria($project: String!, $sequencingType: String!) {
        project(name: $project) {
            sequencingGroups(type: {eq: $sequencingType}) {
                id
                meta
                assays {
                    id
                    meta
                }
            }
        }
    }
    """
)

# Facility specific regular expressions
# VCGS fastq
# This is the current name format
vcgs_fastq_regex = (
    r'(?P<run_date>\d{6})_(?P<g2>[A-Z\d]+)_(?P<g3>\d{4})_'
    r'(?P<g4>[A-Z]{2}\d+)_(?P<sample_id>[\w\d-]+)_(?P<library_id>[A-Z\d-]+)_'
    r'(?P<library_type>[\w\d]+)_(?P<lane>L\d+)_(?P<read>R[12])\.fastq\.gz'
)
# Pre mid 2018 the library id was not included:
vcgs_fastq_pre2018_regex = (
    r'(?P<run_date>\d{6})_(?P<g2>[A-Z\d]+)_(?P<g3>\d{4})_'
    r'(?P<g4>[A-Z]{2}\d+)_(?P<sample_id>[\w\d-]+)_'
    r'(?P<library_type>[\w\d]+)_(?P<lane>L\d+)_(?P<read>R[12])\.fastq\.gz'
)

# Garvan fastq
garvan_fastq_regex = (
    r'(?P<flowcell_id>[A-Z0-9]+_\d)_(?P<rundate>\d{6})_'
    r'(?P<sample_id>[A-Z]{2}\d{8})_(?P<species>[\w-]+)_'
    r'(?P<library_barcode>[ACGT]+-[ACGT]+)_(?P<batch_submission_id>R_\d{6}_[A-Z]{6})_'
    r'(?P<sample_type>DNA)_(?P<lane>[A-Z]\d{3})_(?P<read>R[12])\.fastq\.gz'
)


def check_assay_meta_fields(assays: list[dict], update_sequencing_groups: bool):
    """Check if assay meta fields are set and log if not."""
    assay_meta: dict[int, dict] = {}
    for assay in assays:
        assay_id = assay.get('id')
        current_library_type = assay['meta'].get('library_type')

        # Quick validation
        if current_library_type and not update_sequencing_groups:
            logging.info(
                f'Assay {assay_id} already has current_library_type set: {current_library_type}. Skipping...'
            )
            continue

        assay_meta_fields_to_update = {}

        try:
            fastq_filename = assay.get('meta').get('reads')[0].get('basename')

        except (TypeError, KeyError):
            # Check if this is a bam ingested with a manifest that includes design_description
            if design_description := assay.get('meta', {}).get('design_description'):
                assay_meta_fields_to_update['library_type'] = design_description
                fastq_filename = 'dummy-file-name'
            else:
                # Can't determine fastq_filename
                logging.warning(
                    f'Cant extract fastq_filename for assay {assay_id}. Skipping {assay}'
                )
                continue

        # Match VCGS standard fastq pattern
        if match := re.match(vcgs_fastq_regex, fastq_filename):
            assay_meta_fields_to_update['facility'] = 'vcgs'
            assay_meta_fields_to_update['library_type'] = match.group('library_type')

        # Match VCGS pre2018 fastq pattern
        elif match := re.match(vcgs_fastq_pre2018_regex, fastq_filename):
            assay_meta_fields_to_update['facility'] = 'vcgs'
            assay_meta_fields_to_update['library_type'] = match.group('library_type')

        # Match Garvan standard fastq pattern
        elif match := re.match(garvan_fastq_regex, fastq_filename):
            assay_meta_fields_to_update['facility'] = 'garvan'

        # Check if this is a bam ingested with a manifest that includes design_description
        elif assay['meta'].get('design_description'):
            assay_meta_fields_to_update['library_type'] = assay['meta'].get(
                'design_description'
            )

        else:
            logging.warning(
                f'No file name match found for assay {assay_id}. Skipping {fastq_filename}.'
            )

        assay_meta[assay_id] = assay_meta_fields_to_update

    return assay_meta


async def update_assays_async(assays_to_update: list[dict]):
    """Update assays with new meta fields."""
    asapi = AssayApi()
    updates = []
    for assay in assays_to_update:
        for assay_id, assay_meta_fields_to_update in assay.items():
            if assay_meta_fields_to_update:
                updates.append(
                    asapi.update_assay_async(AssayUpsert(id=assay_id, meta=assay_meta_fields_to_update),)
                )
    return await asyncio.gather(*updates)


async def update_sequencing_groups_async(sequencing_groups_to_update: list[dict], project: str):
    """Update sequencing groups with new meta fields."""
    sgapi = SequencingGroupApi()
    updates = []
    for sequencing_group in sequencing_groups_to_update:
        for sequencing_group_id, sg_meta_fields_to_update in sequencing_group.items():
            if sg_meta_fields_to_update:
                updates.append(
                    sgapi.update_sequencing_group_async(
                        sequencing_group_id=sequencing_group_id,
                        project=project,
                        sequencing_group_meta_update_model=SequencingGroupMetaUpdateModel(meta=sg_meta_fields_to_update)
                    )
                )
    return await asyncio.gather(*updates)


@click.command()
@click.option(
    '-p',
    '--project',
    required=True,
    help='The metamist project ($DATASET)',
)
@click.option(
    '-s',
    '--sequencing-type',
    required=True,
    help='The sequencing type to filter sequencing groups on',
)
@click.option(
    '-u',
    '--update-sequencing-groups',
    is_flag=True,
    default=False,
    help='Update the sequencing group meta fields',
)
@click.option(
    '-d',
    '--dry-run',
    is_flag=True,
    default=False,
    help='Do not save changes to metamist',
)
def main(project: str, sequencing_type: str, update_sequencing_groups: bool, dry_run: bool):
    """Back populate facility and library_type meta fields for existing assays and sequencing groups."""
    sg_assays: defaultdict[str, list[dict]] = defaultdict(list)
    sg_meta: dict[str, dict] = {}

    # Get all sequencing groups and their assays for the project (for a specific sequencing type)
    project_sg_assays: dict[str, dict] = query(_sg_assays_query, variables={'project': project, 'sequencingType': sequencing_type})
    for sequencing_group in project_sg_assays['project']['sequencingGroups']:  # pylint: disable=unsubscriptable-object
        sg_id = sequencing_group['id']
        sg_meta[sg_id] = sequencing_group['meta']
        assays = sequencing_group['assays']
        sg_assays[sg_id].extend(assays)

    # For logs
    assays_to_update: list[dict[str, dict]] = []
    sequencing_groups_to_update: list[dict[str, dict]] = []

    for sequencing_group, assays in sg_assays.items():
        current_sg_facility = sg_meta[sequencing_group].get('facility')
        current_sg_library_type = sg_meta[sequencing_group].get('library_type')
        if current_sg_library_type and current_sg_facility and update_sequencing_groups:
            logging.info(
                f'{sequencing_group} already has library type and facility set: {current_sg_library_type}, {current_sg_facility}. Skipping...'
            )
            continue

        sg_meta_fields_to_update: dict[str, str] = {}
        assay_meta = check_assay_meta_fields(assays, update_sequencing_groups)
        for assay_id, assay_meta_fields_to_update in assay_meta.items():
            if assay_meta_fields_to_update:
                if update_sequencing_groups:
                    sg_meta_fields_to_update['facility'] = assay_meta_fields_to_update['facility']
                    if library_type := assay_meta_fields_to_update.get('library_type'):
                        sg_meta_fields_to_update['library_type'] = library_type
                assays_to_update.append({assay_id: assay_meta_fields_to_update})

        if sg_meta_fields_to_update and update_sequencing_groups:
            sequencing_groups_to_update.append({sequencing_group: sg_meta_fields_to_update})

    if dry_run:
        logging.info(
            f'Dummy run. Would have updated {len(assays_to_update)} assays.\n\n{assays_to_update}'
        )
        if update_sequencing_groups:
            logging.info(
                f'\n\nDummy run. Would have updated {len(sequencing_groups_to_update)} sequencing groups.\n\n{sequencing_groups_to_update}'
            )
    else:
        asyncio.run(update_assays_async(assays_to_update))
        logging.info(f'Updated {len(assays_to_update)} assays.\n\n{assays_to_update}')
        if update_sequencing_groups:
            asyncio.run(update_sequencing_groups_async(sequencing_groups_to_update, project))
            logging.info(
                f'\n\nUpdated {len(sequencing_groups_to_update)} sequencing groups.\n\n{sequencing_groups_to_update}'
            )


if __name__ == '__main__':
    # pylint: disable=no-value-for-parameter
    main()
